{
  "hash": "dc92bc08bc270712580aa9c5a2bc5e92",
  "result": {
    "markdown": "---\ntitle: \"Working Efficiently with Data\"\n---\n\n\nIn this section will focus on best practices for working efficiently with data, primarily with tabular data.\n\n## Use appropriate data structures\n\nTo begin with, let's have a look at differences in performance of working with data in stored in different data structures.\n\n### Matrix instead of data.frame\n\nIf all your tabular data is of a single data type (e.g. `numeric`, `logical`, `character` etc), it can be more efficient to store it as a matrix than as data.frame. That's because many functions can operate it on it with the confidence that all data will indeed be of a single data type instead of having to perform data type coercions or checks on whether the operation is possible.\n\nLet's have a look at an example where we store the same data as a matrix and a data.frame. Our data is a large table with 10,000 rows and 150 columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nrows <- 10000\ncols <- 150\n\ndata_mat <- matrix(rnorm(rows * cols, mean = 10), ncol = cols)\ndata_df <- as.data.frame(data_mat)\n```\n:::\n\n\nLet's now set up a `bench::press()` and test the performance of a number of function on the two data structures.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::press(\n    fn_name = c(\"rowSums\", \"rowMeans\", \"colSums\", \"colMeans\", \"sqrt\"),\n    {\n        fn <- get(fn_name)\n        bench::mark(\n            df = fn(data_df),\n            mat = fn(data_mat),\n            check = FALSE\n        )\n    }\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRunning with:\n  fn_name \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n1 rowSums \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n2 rowMeans\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n3 colSums \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n4 colMeans\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n5 sqrt    \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 7\n   expression fn_name       min   median `itr/sec` mem_alloc `gc/sec`\n   <bch:expr> <chr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n 1 df         rowSums    2.08ms   2.71ms      361.   11.53MB   356.  \n 2 mat        rowSums  354.12µs 366.38µs     2724.   78.17KB     8.17\n 3 df         rowMeans   2.07ms   2.87ms      366.   11.53MB   228.  \n 4 mat        rowMeans 354.12µs  366.7µs     2723.   78.17KB     4.05\n 5 df         colSums    3.09ms    3.6ms      270.   11.45MB   137.  \n 6 mat        colSums    1.37ms   1.37ms      728.    1.22KB     0   \n 7 df         colMeans   3.08ms    3.4ms      277.   11.45MB   142.  \n 8 mat        colMeans   1.37ms   1.37ms      729.    1.22KB     0   \n 9 df         sqrt       2.46ms   2.58ms      386.   11.74MB   252.  \n10 mat        sqrt       1.56ms   1.66ms      571.   11.44MB   194.  \n```\n:::\n:::\n\n\nMatrices are clearly more performant especially on row wise operations. They are still faster on column wise operations by a decent margin as well as vectorised mathematical operations like `sqrt()` although less so.\n\n### Single vs double precision floating point\n\nBase R numeric types are either \"double\" which indicates double precision floating points or integer.\n\nPackage `float` enables storing numeric values as single precision (aka). Floats have half the precision of double precision data, for a **pretty obvious performance vs accuracy tradeoff**.\n\nA matrix of floats should use about half as much memory as a matrix of doubles which can be really useful if you're dealing with data approaching memory limits:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(float)\ndata_fl_mat <- fl(data_mat)\n\npryr::object_size(data_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12.00 MB\n```\n:::\n\n```{.r .cell-code}\npryr::object_size(data_fl_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6.00 MB\n```\n:::\n:::\n\n\nIn addition many matrix routines will generally compute about twice as fast on them as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::press(\n    fn_name = c(\"rowSums\", \"colSums\", \"sqrt\"),\n    {\n        fn <- get(fn_name)\n        bench::mark(\n            mat = fn(data_mat),\n            fl_mat = fn(data_fl_mat),\n            check = FALSE\n        )\n    }\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRunning with:\n  fn_name\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n1 rowSums\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n2 colSums\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n3 sqrt   \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  expression fn_name      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <chr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 mat        rowSums 348.17µs  356.5µs     2794.   78.17KB     4.05\n2 fl_mat     rowSums 155.72µs 160.23µs     6110.   41.35KB    21.2 \n3 mat        colSums   1.37ms   1.37ms      727.    1.22KB     0   \n4 fl_mat     colSums   1.41ms   1.41ms      708.      976B     4.04\n5 mat        sqrt       1.6ms   1.96ms      539.   11.44MB   183.  \n6 fl_mat     sqrt       487µs 518.69µs     1895.    5.72MB   190.  \n```\n:::\n:::\n\n\nBy switching to single precision floating points, we see additional speed ups of row-wise operations although none for column-wise operations. We do however see a huge speed up of the vectorised calculation of `sqrt()`.\n\nFor more details on the routines available, consult the [`float` pkg documentation](https://cran.r-project.org/web/packages/float/readme/README.html).\n\n::: callout-caution\n**A note of caution:** The results of matrix routines on float data will not be as accurate, and are much more prone to roundoff error/mass cancellation issues. If your data is [well-conditioned](https://en.wikipedia.org/wiki/Condition_number), then using floats is \"probably\" fine for many applications. They can be an invaluable approach to consider when working with data that cannot but must fit into memory as double.\n:::\n\n### Efficient Indexing\n\nBefore moving on to data munging and more complex manipulating of data, let's briefly have at look at different approaches for indexing, i.e. the process of extracting specific elements of a data structure.\n\n#### Indexing tabular data\n\nLet's set up a very simple test, say we want to extract rows 10 to 15 from the 55th column of our example data.\n\nLet's compare using a variety of base R approaches on both our matrix and data.frame. We'll also include the `dplyr` version of extracting the same values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    data_mat[10:15, 55],\n    data_df[[55]][10:15],\n    data_df[[\"V55\"]][10:15],\n    data_df[10:15, 55],\n    data_df[10:15, \"V55\"],\n    dplyr = {\n    select(data_df, V55) %>%\n        slice(10:15) %>%\n        pull()\n    }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  expression                   min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>              <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 data_mat[10:15, 55]     205.01ns 287.02ns  3139300.        0B      0  \n2 data_df[[55]][10:15]      1.89µs   2.13µs   454729.        0B     45.5\n3 data_df[[\"V55\"]][10:15]   2.13µs   2.46µs   399046.        0B     39.9\n4 data_df[10:15, 55]        3.94µs   4.39µs   220546.    1.22KB     22.1\n5 data_df[10:15, \"V55\"]     4.18µs   4.76µs   202873.    1.22KB     20.3\n6 dplyr                   964.52µs      1ms      955.    2.05MB     24.0\n```\n:::\n:::\n\n\n-   Indexing matrices is by far the fastest, almost by an order of magnitude!\n\n-   It can be more efficient to extract vectors from a data.frame and then subset those instead of indexing rows and columns in the data.frame directly.\n\n-   Base R is much faster than `dplyr` for simple indexing.\n\n#### Indexing lists\n\nSimilarly there is a variety of ways of indexing lists, some more efficient than others. Here I've just created a list where each element is an element of `letters` while each element's name in the corresponding capital letter\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletter_list <- setNames(letters, LETTERS) |>\n    as.list()\n\nhead(letter_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$A\n[1] \"a\"\n\n$B\n[1] \"b\"\n\n$C\n[1] \"c\"\n\n$D\n[1] \"d\"\n\n$E\n[1] \"e\"\n\n$F\n[1] \"f\"\n```\n:::\n:::\n\n\nSay we want to access the value in the fourth element, element `\"D\"`.\n\nI've put together a number of approaches, ranging from using `purrr::pluck()` and piping the data (something I see quite often these days) to standard base indexing using in numeric indexing and indexing by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    magrittr_pipe = {\n        letter_list %>%\n        purrr::pluck(\"D\")\n    },\n    base_r_pipe = {\n        letter_list |>\n        purrr::pluck(\"D\")\n    },\n    purrr_no_pipe = {\n        purrr::pluck(letter_list, \"D\") \n    },\n    base_dollar_idx ={\n        letter_list$D\n    },\n    base_chr_idx ={\n        letter_list[[\"D\"]]\n    },\n    base_int_idx ={\n        letter_list[[4]]\n    }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 magrittr_pipe     3.73µs   4.18µs   235530.     273KB     23.6\n2 base_r_pipe       2.95µs    3.2µs   306067.        0B     30.6\n3 purrr_no_pipe     2.95µs    3.2µs   307520.        0B     30.8\n4 base_dollar_idx  41.04ns 123.05ns  7614980.        0B      0  \n5 base_chr_idx           0  82.02ns 12174874.        0B      0  \n6 base_int_idx           0  41.04ns 14392882.        0B   1439. \n```\n:::\n:::\n\n\n-   The fastest way to index a list is using base R and a numeric index or character name.\n\n-   Dollar sign indexing is slower (and not as safe) because R looks for partial matches.\n\n-   `purrr::pluck()` is orders of magnitude slower, especially when a pipe is thrown in there for good measure! If you're doing simple indexing, I would avoid `pluck()` all together.\n\nBase R can be extremely efficient at indexing into data structures, especially matrices.\n\nAgain, here we are in the real of micro-optimisations, but if you're going to be running your code 1000s of times, these micro-optimisations soon add up.\n\n# Efficient Data munging\n\nIn the real word, we're often dealing with mixed types of data that cannot be stored in a matrix and need to perform more complicated operations than summing rows or indexing.\n\nSo let's now turn to some of the most common data munging operations and compare and contrast the performance of a few of the most well known packages in use today to work with data.frames.\n\n#### **`dplyr`**\n\n`dplyr` is the flag ship package of the tidyverse, providing a consistent set of verb functions to help address the most common data manipulation challenges in a user friendly way.\n\n##### **PROs**\n\n-   well integrated collection of functions for data munging.\n\n-   easy to read and interpret code even as a beginner.\n\n-   reasoning about operations made easier by the use of pipes as well as doing away with the need for intermediate objects.\n\n-   In addition to data frames/tibbles, dplyr makes working with other computational backends like databases and arrow tables accessible and efficient.\n\n##### **CONs**\n\n-   quite verbose and code can end up running across many lines.\n\n-   can be (comparatively) slow.\n\n##### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% \n    filter(wt < 5) %>% \n    mutate(l100k = 235.21 / mpg) %>% # liters / 100 km\n    group_by(cyl) %>% \n    summarise(l100k = mean(l100k))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    cyl l100k\n  <dbl> <dbl>\n1     4  9.05\n2     6 12.0 \n3     8 14.9 \n```\n:::\n:::\n\n\n#### **`data.table`**\n\nProvides a high-performance version of [base R](https://www.r-project.org/about.html)'s `data.frame` with syntax and feature enhancements for ease of use, convenience and programming speed. It has it's own compact syntax that feels like a blend of base R and some dplyr concepts (e.g. the `by` argument for grouping operations by syntax.\n\nAt it's most basic, data.table syntax can be summarised as\n\n>     DT[i, j, by]\n\nwhere `i` is used for filtering or reordering rows, `j` is used for manipulating and selecting columns and `by` is used for grouping operations.\n\nInstead of piping `data.table` uses the concept of chaining, where subsequent expressions are performed creating a chain of operations through the construct `DT[...][...][...] etc`.\n\n##### **PROs**\n\n-   syntax is very compact\n\n-   generally faster for many operation, especially as the sizes of datasets grow\n\n-   operations that modify data in place improve memory efficiency and can also boost performance\n\n-   extremely fast functionality for reading in data through function `fread`.\n\n##### **CONs**\n\n-   Syntax can be confusing to understand and work with without familiarity with the package especially when chaining multiple operations\n\n##### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'data.table'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n```\n:::\n\n```{.r .cell-code}\nmtcars_dt <- as.data.table(mtcars)\nmtcars_dt[wt < 5, `:=`(l100k = 235.21/mpg)][, .(l100k = mean(l100k)), \n    keyby = .(cyl)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   cyl     l100k\n1:   4  9.048898\n2:   6 11.970180\n3:   8        NA\n```\n:::\n:::\n\n\n#### **`dtplyr`**\n\ndtplyr provides a [data.table](http://r-datatable.com/) backend for dplyr. The goal of `dtplyr` is to allow you to write dplyr code that is automatically translated to the equivalent, but usually much faster, data.table code. The current implementation focuses on lazy evaluation triggered by use of [`lazy_dt()`](https://dtplyr.tidyverse.org/reference/lazy_dt.html). This means that **no computation is performed until you explicitly request it with [`as.data.table()`](https://rdatatable.gitlab.io/data.table/reference/as.data.table.html), [`as.data.frame()`](https://rdrr.io/r/base/as.data.frame.html) or [`as_tibble()`](https://tibble.tidyverse.org/reference/as_tibble.html).**\n\n##### **PROs**\n\n-   provides ability to write dplyr code with often improved performance.\n\n-   can be useful for learning how to translate `dplyr` code to `data.table` code.\n\n##### **CONs**\n\n-   does not always reach the performance of data.table and translations for some operations are yet to be available.\n\n##### Example\n\nFirst a `lazy_dt` needs to be created with `lazy_dt().` You can then use most dplyr functions as normal. Executing the code shows the `data.table` translation at the top section in `Call:`. This can be really useful for trying to learn `dplyr` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dtplyr)\nmtcars_dtp <- lazy_dt(mtcars)\nmtcars_dtp %>% \n    filter(wt < 5) %>% \n    mutate(l100k = 235.21 / mpg) %>% # liters / 100 km\n    group_by(cyl) %>% \n    summarise(l100k = mean(l100k))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSource: local data table [3 x 2]\nCall:   `_DT1`[wt < 5][, `:=`(l100k = 235.21/mpg)][, .(l100k = mean(l100k)), \n    keyby = .(cyl)]\n\n    cyl l100k\n  <dbl> <dbl>\n1     4  9.05\n2     6 12.0 \n3     8 14.9 \n\n# Use as.data.table()/as.data.frame()/as_tibble() to access results\n```\n:::\n:::\n\n\nThe results of executing the above code cannot be accessed until one of `as.data.table()/as.data.frame()/as_tibble()` or even `collect()` is called at the end.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_dtp %>% \n    filter(wt < 5) %>% \n    mutate(l100k = 235.21 / mpg) %>% # liters / 100 km\n    group_by(cyl) %>% \n    summarise(l100k = mean(l100k)) %>%\n    as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    cyl l100k\n  <dbl> <dbl>\n1     4  9.05\n2     6 12.0 \n3     8 14.9 \n```\n:::\n:::\n\n\n## Benchmarking data munging operations\n\n### Load data and create data structures for comparison\n\nIn this section we'll use the synthetic datasets created for this course. I'll be using the file with 10,000,000 but If you prefer to use a smaller one feel free to. Note though that, in general, the benefits of using `data.table` increase with the size of the dataset.\n\nLet's go ahead and load our `parquet` data using `arrow::read_parquet()` which loads the data as a `tibble`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_df <- arrow::read_parquet(\"data/synthpop_10000000.parquet\")\n```\n:::\n\n\nWe can have a look at the characteristics if our data using `skimr::skim()`.\n\n*Note: this can take a lot of time to compute so feel free to skip this step.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nskimr::skim(data_df)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |         |\n|:------------------------|:--------|\n|Name                     |data_df  |\n|Number of rows           |10000000 |\n|Number of columns        |13       |\n|_______________________  |         |\n|Column type frequency:   |         |\n|character                |6        |\n|logical                  |3        |\n|numeric                  |4        |\n|________________________ |         |\n|Group variables          |None     |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|sex           |         0|          1.00|   4|   6|     0|        2|          0|\n|agegr         |      8096|          1.00|   3|   5|     0|        6|          0|\n|socprof       |     66184|          0.99|   6|  27|     0|        9|          0|\n|marital       |     17069|          1.00|   6|  18|     0|        6|          0|\n|edu           |     13038|          1.00|   9|  24|     0|        4|          0|\n|location      |         0|          1.00|   3|  26|     0|     2623|          0|\n\n\n**Variable type: logical**\n\n|skim_variable | n_missing| complete_rate| mean|count                      |\n|:-------------|---------:|-------------:|----:|:--------------------------|\n|sport         |         0|             1| 0.66|TRU: 6565029, FAL: 3434971 |\n|smoke         |         0|             1| 0.26|FAL: 7420496, TRU: 2579504 |\n|alcabuse      |         0|             1| 0.06|FAL: 9370742, TRU: 629258  |\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|    mean|      sd|     p0|   p25|     p50|     p75|     p100|hist  |\n|:-------------|---------:|-------------:|-------:|-------:|------:|-----:|-------:|-------:|--------:|:-----|\n|age           |         0|          1.00|   47.68|   18.51|  16.00|  32.0|   49.00|   61.00|    97.00|▆▆▇▃▁ |\n|income        |   2573137|          0.74| 1639.42| 1222.73| 100.00| 960.0| 1330.00| 2000.00| 16000.00|▇▁▁▁▁ |\n|nociga        |   7473351|          0.25|   15.41|    7.91|   1.00|  10.0|   15.00|   20.00|    60.00|▇▇▁▁▁ |\n|bmi           |    121355|          0.99|   25.95|    4.67|  12.96|  22.6|   25.61|   28.72|    61.36|▃▇▁▁▁ |\n:::\n:::\n\n\nLet's now create a `data.table` and `lazy_dt` from our data to run our benchmarks against.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_dt <- as.data.table(data_df)\ndata_dtp <- lazy_dt(data_dt)\n```\n:::\n\n\n### Basic Benchmarks\n\nFirst, let's compare some basic operations on our data and include base R approaches.\n\n#### Sub-setting\n\nLet's start with some simple sub-setting.\n\n##### Column sub-setting\n\nFirst let's look at column sub-setting for the columns `\"age\"`, `\"marital\"`, `\"income\"` and `\"sport\"` and compare base R, `dplyr`, `dtplyr` and data.table approaches:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    \"Base R\" = {\n        data_df[, c(\"age\", \"marital\", \"income\", \"sport\")]\n    },\n    \"dplyr\" = {\n        select(data_df, age, marital, income, sport)\n    },\n    \"dtplyr\" = {\n        select(data_dtp, age, marital, income, sport) %>%\n            as_tibble()\n    },\n    \"data.table\" = {\n        data_dt[, .(age, marital, income, sport)]\n    },\n    check = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Base R       9.43µs  10.04µs   98372.         0B     19.7\n2 dplyr      990.11µs   1.03ms     968.     16.8KB     16.9\n3 dtplyr      33.82ms  34.34ms      25.4   381.8MB     33.9\n4 data.table  32.32ms  32.46ms      30.6   381.5MB     38.3\n```\n:::\n:::\n\n\nWe can see that in the case of column sub-setting, base R is actually highly performant, both in terms of memory and speed, almost 10x faster than `dplyr` which is the next fastest.\n\nSurprisingly, `data.table` and `dtplyr` are both comparatively slow for simple column sub-setting operations.\n\n##### Row filtering\n\nLet's move on to comparing row filtering approaches. Let's filter for rows where values of `income` are not `NA` and `age` is greater than 30:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  \"Base R\" = {\n    data_df[!is.na(data_df$income) & data_df$age > 30, ]\n  },\n  \"dplyr\" = {\n    filter(data_df, \n                  !is.na(income) & age > 30) \n  },\n  \"dtplyr\" = {\n    filter(data_dtp, \n                  !is.na(income) & age > 30) %>%\n          as_tibble()\n  },\n  \"data.table\" = {\n    data_dt[!is.na(income) & age > 30, ]\n  },\n  check = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Base R        1.03s    1.03s     0.966     662MB     7.73\n2 dplyr      972.55ms 972.55ms     1.03      777MB     9.25\n3 dtplyr     287.76ms 303.52ms     3.29      700MB     1.65\n4 data.table 282.24ms 312.47ms     3.20      700MB     1.60\n```\n:::\n:::\n\n\nIn the case of row filtering, we find exactly the opposite! Both base R and `dplyr` perform similarly but are both significantly slower than `data.table` and `dtplyr`.\n\nThis is actually where `data.table` (and conversely `dtplyr`) really shine, in filtering rows.\n\n::: callout-tip\nFiltering using `data.table` can be speeded up even more using [keys](https://rdatatable.gitlab.io/data.table/articles/datatable-keys-fast-subset.html) and [secondary indices](https://rdatatable.gitlab.io/data.table/articles/datatable-secondary-indices-and-auto-indexing.html). So there's a lot of potential for further optimisation if you need to perform repeated filtering or aggregating on specific columns. Consult the `data.table` documentation for more details.\n:::\n\n##### Combined column and row sub-setting\n\nLastly, let's perform sub-setting involving both the row and column sub-setting we looked at previously.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  \"Base R\" = {\n    data_df[!is.na(data_df$income) & data_df$age > 30, \n            c(\"age\", \"marital\", \"income\", \"sport\")]\n  },\n  \"dplyr\" = {\n    filter(data_df, \n                  !is.na(income) & age > 30) %>%\n          select(age, marital, income, sport)\n  },\n  \"dtplyr\" = {\n    filter(data_dtp, \n                  !is.na(income) & age > 30) %>%\n          select(age, marital, income, sport) %>%\n          as_tibble()\n  },\n  \"data.table\" = {\n    data_dt[!is.na(income) & age > 30, \n            .(age, marital, income, sport)]\n  },\n  check = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Base R        750ms    750ms      1.33     298MB    10.7 \n2 dplyr         946ms    946ms      1.06     777MB     9.51\n3 dtplyr        158ms    162ms      5.68     482MB     1.89\n4 data.table    172ms    174ms      5.31     482MB     5.31\n```\n:::\n:::\n\n\nOverall, the computing requirements of filtering rows overshadows that of sub-setting columns so `data.table` emerge as the overall winner and the performance boost will increase in most cases with the size of the data set.\n\n#### Ordering\n\nLet's now have a look at performance of ordering. Let's order our data on the values of a single column, `income`.\n\nIn `data.table` there are a couple of approaches that can be used. The first is to use `order()` in `i` which creates a vector of indices indicating the order of the values in the column name passed to `order()` and effectively uses those indices to sub-set the rows in the correct order. This version orders `NA`s at the bottom as do all the other approaches.\n\nA more efficient approach is to use `data.table`'s function `setorder()`. This version orders `NA`s at the top.\n\nBecause `setorder()` would modify `data_dt` in place, in one test we'll perform the ordering on a copy of `data_dt` using function `copy` to better reflect the behaviour of the other expressions.\n\nWe'll also test the speed of modifying in place though too. The modification in place behaviour of `data.table` poses challenges in a repeated testing environment, because, once the object is modified in place the first time the ordering is performed, subsequent runs do not reflect any ordering operation as the object is already ordered. To address this, I've turned memory profiling off, as this runs the code once to get the memory profile regardless of the number of test iterations, and then set the number of iterations to 1 so that each test is run only once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  \"Base R\" = {\n    data_df[order(data_df$income),]\n  },\n  \"dplyr\" = {\n    arrange(data_df, income)\n  },\n  \n  \"dtplyr\" = {\n    arrange(data_dtp, income) %>%\n          as_tibble()\n  },\n  \"data.table_order\" = {\n    data_dt[order(income)]\n  },\n  \"data.table_setorder_copy\" = {\n    setorder(copy(data_dt), income)\n  },\n  \"data.table_setorder\" = {\n      setorder(data_dt, income)\n  },\n  iterations = 1,\n  memory = FALSE,\n  check = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  expression                    min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>               <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Base R                      1.24s    1.24s     0.806        NA    1.61 \n2 dplyr                       1.12s    1.12s     0.892        NA    0.892\n3 dtplyr                   977.45ms 977.45ms     1.02         NA    0    \n4 data.table_order            1.08s    1.08s     0.922        NA    0.922\n5 data.table_setorder_copy 526.98ms 526.98ms     1.90         NA    0    \n6 data.table_setorder      455.79ms 455.79ms     2.19         NA    0    \n```\n:::\n:::\n\n\nBase R, `dplyr` and ordering a `data.table` using `order()` come back as the slowest approaches. `setorder()` is faster, even on a copy of the object, with `dtplyr` coming up as marginally fastest.\n\nBefore moving on, let's reset `data_df` which we just modified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_dt <- as.data.table(data_df)\n```\n:::\n\n\n#### Mutating\n\nFor our final basic test, let's have a look at mutating, i.e. creating a new column from calculation performed using values from another column in our dataset. For this example, we'll calculate the relative income compared to mean income across the whole population.\n\nTo compare similar behaviour and allow us to include a comparison to base R, we'll write our tests so that the original object is actually modified. We'll again turn off memory profiling and set the number of iterations again to ensure we're not re-modifying previously modified objects which could affect our results. Also to ensure our original data objects are not overwritten by the test, we perform the testing in a new and separate environment by using `bench::marks()`'s `env` argument. This however does not work for `data.table`s so we'll again need to reset `data_dt` once we're done.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    \"Base R\" = {\n        data_df$rel_income <- data_df$income/mean(data_df$income, na.rm = TRUE)\n    },\n    \"dplyr\" = {\n        data_df <- mutate(data_df, rel_income = income/mean(income, na.rm = TRUE))\n    },\n    \"dtplyr\" = {\n        data_dtp <- mutate(data_dtp, rel_income = income/mean(income, na.rm = TRUE)) %>%\n            as_tibble()\n    },\n    \"data.table\" = {\n        data_dt[, rel_income := income/mean(income, na.rm = TRUE)]\n    },\n  iterations = 1,\n  memory = FALSE,\n  check = FALSE,\n  env = new.env())\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Base R        1.39s    1.39s     0.719        NA    10.1 \n2 dplyr         1.07s    1.07s     0.931        NA    14.0 \n3 dtplyr     116.46ms 116.46ms     8.59         NA     0   \n4 data.table 131.61ms 131.61ms     7.60         NA     7.60\n```\n:::\n:::\n\n\nHere `data.table()` is the clear winner, over 10 faster than base R and 8 faster than `dplyr`. `dtplyr` is still fast but almost 2x slower than `data.table`.\n\nBecause we've modified `data_dt` again, let's go ahead and reset it before moving on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_dt <- as.data.table(data_df)\n```\n:::\n\n\n### More complex examples\n\nNow that we've looked at the isolated performance of different types of data munging, let's explore performance of more complex computations on our data. This also gives us an opportunity to explore `data.table` syntax a bit more and compare to `dplyr` syntax.\n\n#### Example 1\n\nIn this example we'll combine filtering, selecting and arranging operations and this time we'll perform arranging over a larger number of columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    dplyr = {\n        filter(data_df,\n               age > 50L & age < 60L, \n               income < 300) %>%\n            select(bmi, age, income, nociga, sex) %>%\n            arrange(bmi, age, income, nociga, sex)\n    },\n    dtplyr = {\n        filter(data_dtp,\n               age > 50L & age < 60L, \n               income < 300) %>%\n            select(bmi, age, income, nociga, sex) %>%\n            arrange(bmi, age, income, nociga, sex) %>%\n            as_tibble()\n        },\n    data.table = {\n        data_dt[age > 50L & age < 60L & income < 300, \n                .(bmi, age, income, nociga, sex)][\n                    order(bmi, age, income, nociga, sex)\n                    ]\n    },\n    iterations = 5,\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 dplyr       117.6ms  124.3ms      8.04     269MB     2.01\n2 dtplyr       90.8ms   91.4ms     10.9      230MB     2.72\n3 data.table   89.9ms     91ms     11.0      230MB     2.75\n```\n:::\n:::\n\n\n`data.table` is fastest with `dtplyr` close behind, yet the differences are not as big as some of the order of magnitude differences we've seen in other examples.\n\n#### Example 2\n\nLet's explore some performance differences on aggregating across groups and calculating summary statistics. We'll start some example with some complex filtering, then group our results by marital status and then calculate min, max and mean income across each group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n        dplyr = {\n            filter(data_df,\n                   age > 65L,\n                   sex == \"MALE\",\n                   sport == TRUE,\n                   !is.na(income),\n                   !is.na(marital)) %>%\n                group_by(marital) %>%\n                summarise(min_income = min(income),\n                          max_income = max(income),\n                          mean_income = mean(income))\n    },\n    dtplyr = {\n            filter(data_dtp,\n                   age > 65L,\n                   sex == \"MALE\",\n                   sport == TRUE,\n                   !is.na(income),\n                   !is.na(marital)) %>%\n                group_by(marital) %>%\n                summarise(min_income = min(income),\n                          max_income = max(income),\n                          mean_income = mean(income)) %>%\n            as_tibble()\n    },\n    data.table = {\n        data_dt[ age > 65L &\n                   sex == \"MALE\" &\n                   sport == TRUE &\n                   !is.na(income) &\n                   !is.na(marital), \n                  .(min_income = min(income),\n                          max_income = max(income),\n                          mean_income = mean(income)),\n                 keyby = .(marital)]\n        },\n    iterations = 5,\n    memory = FALSE,\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 dplyr         895ms    899ms      1.05        NA    8.84 \n2 dtplyr        215ms    221ms      4.41        NA    0.882\n3 data.table    206ms    207ms      4.71        NA    0.941\n```\n:::\n:::\n\n\nHere we're back to an order of magnitude difference in performance between `data.table/dtplyr` and `dplyr`, primarily due to the excellent performance of `data.table` on filtering.\n\n#### Example 3\n\nIn our third example we'll add some mutating and creating a new column, `income_group`, which splits `income` into income brackets. We'll then calculate mean `bmi` across each income group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    dplyr = {\n        filter(data_df, !is.na(income)) %>%\n            mutate(income_group = cut(income,\n                                      breaks = seq(0, 16000, by = 1000),\n                                      include.lowest = T,\n                                      right = F)\n                   \n            ) %>%\n            group_by(income_group) %>%\n            summarise(bmi_mean = mean(bmi, na.rm = TRUE))\n    },\n    dtplyr = {\n        filter(data_dtp, !is.na(income)) %>%\n            mutate(income_group = cut(income,\n                                      breaks = seq(0, 16000, by = 1000),\n                                      include.lowest = T,\n                                      right = F)\n                   \n            ) %>%\n            group_by(income_group) %>%\n            summarise(bmi_mean = mean(bmi, na.rm = TRUE)) %>%\n            as_tibble()\n    },\n    data.table = {\n        data_dt[!is.na(income)][, \n                                `:=`(income_group = cut(income, \n                                                        breaks = seq(0, 16000, by = 1000),\n                                                        include.lowest = TRUE, \n                                                        right = FALSE)\n                                )][, .(bmi_mean = mean(bmi, na.rm = TRUE)), \n                                   keyby = .(income_group)]\n    },\n    iterations = 5,\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 dplyr         1.23s    1.34s     0.739    1.38GB     6.36\n2 dtplyr     537.83ms 659.77ms     1.49     1.18GB     1.49\n3 data.table 587.47ms 635.62ms     1.50     1.18GB     1.81\n```\n:::\n:::\n\n\nIn this example, `data.table` and `dtplyr` are comparable and still much faster than that `dplyr`.\n\n#### Example 4\n\nFor our final example, we'll again perform some initial filtering but this time aggregate across location which has a much higher number of groups than marital status. We'll then calculate mean number of cigarettes smoked (across smokers only) and the proportion of the population at a given location that are smokers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    dplyr = {\n        filter(data_df, \n               age < 30) %>%\n            group_by(location) %>%\n            summarise(nociga_mean = mean(nociga, na.rm = TRUE),\n                      prop_smoke = sum(smoke)/n())\n    },\n    dtplyr = {\n        filter(data_dtp, \n               age < 30) %>%\n            group_by(location) %>%\n            summarise(nociga_mean = mean(nociga, na.rm = TRUE),\n                      prop_smoke = sum(smoke)/n()) %>%\n            as_tibble()\n    },\n    data.table = {\n        data_dt[age < 30][, .(nociga_mean = mean(nociga, na.rm = TRUE), \n                              prop_smoke = sum(smoke)/.N), \n                          keyby = .(location)]\n    },\n    iterations = 5,\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 dplyr         171ms    173ms      5.80     412MB     3.87\n2 dtplyr        134ms    136ms      7.36     262MB     0   \n3 data.table    129ms    131ms      7.55     262MB     1.89\n```\n:::\n:::\n\n\nHere, although `data.table` and `dtplyr` are again comparable and still faster than that `dplyr` the difference in perfromance is much smaller, indicating that when aggregating across many groups, `dplyr`'s relative performance appears to catch up.\n\n::: callout-important\n## Take Aways\n\n-   Overall `data.table` performs better across most data munging tasks, often significantly so, with `dtplyr` being comparable or slightly slower but generally faster than `dplyr.`\n\n-   `data.table/dtplyr` are especially fast on row filtering rows, less so on ordering data.\n\n-   Base R is generally much slower for most data munging operations apart from selecting columns where it can actually be the fastest option by quite some margin.\n:::\n\n#### A side note on copying\n\nOne of the features that makes `data.table` very efficient is that it modifies the data in place. None of it's functions and operators create copies when manipulating a `data.table`. This behaviour also extends to using `dtplyr` on a `lazy_dt` object.\n\nLet's have a look at a quick example. Let's perform some data munging on a `tibble`, `data.table` and `lazy_dt` version of the `mtcars` data while using `tracemem()` to keep track of any copies being made during the operations.\n\nLet's filter for `wt < 5` and convert miles per gallon (`mpg`) into liters per 100 km in a new column called `l100k`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data structures\nmtcars_tbl <- as_tibble(mtcars)\nmtcars_dt <- as.data.table(mtcars)\nmtcars_dtp <- lazy_dt(mtcars)\n\n# Tracemem objects\ntracemem(mtcars_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"<0x145ceefc8>\"\n```\n:::\n\n```{.r .cell-code}\ntracemem(mtcars_dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"<0x12493ee00>\"\n```\n:::\n\n```{.r .cell-code}\ntracemem(mtcars_dtp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"<0x120bed068>\"\n```\n:::\n:::\n\n\n##### `tibble`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Munge tibble\nmtcars_tbl %>% \n    filter(wt < 5) %>% \n    mutate(l100k = 235.21 / mpg) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntracemem[0x145ceefc8 -> 0x145c1b078]: initialize <Anonymous> filter_rows filter.data.frame filter mutate %>% eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x145c1b078 -> 0x145c1b128]: names<-.tbl_df names<- initialize <Anonymous> filter_rows filter.data.frame filter mutate %>% eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x145c1b128 -> 0x145c1b1d8]: initialize <Anonymous> filter_rows filter.data.frame filter mutate %>% eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 29 × 12\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb l100k\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 11.2 \n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 11.2 \n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 10.3 \n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 11.0 \n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 12.6 \n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 13.0 \n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 16.4 \n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2  9.64\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 10.3 \n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 12.3 \n# … with 19 more rows\n```\n:::\n:::\n\n\nPerforming the filtering and mutating on a tibble results internally in 3 copies being made! Surprisingly, this happens even when we are just filtering:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_tbl %>% \n    filter(wt < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntracemem[0x145ceefc8 -> 0x127de6208]: initialize <Anonymous> filter_rows filter.data.frame filter %>% eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x127de6208 -> 0x127de62b8]: names<-.tbl_df names<- initialize <Anonymous> filter_rows filter.data.frame filter %>% eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x127de62b8 -> 0x127de6368]: initialize <Anonymous> filter_rows filter.data.frame filter %>% eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 29 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 19 more rows\n```\n:::\n:::\n\n\n##### `data.table`\n\nWhen performing the same operation on a `data.table`, no copies are made:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Munge data.table\nmtcars_dt[wt < 5, `:=`(l100k = 235.21/mpg)]\n```\n:::\n\n\nIndeed we don't even get the results printed out. That because the `data.table` was modified in place, without having to assign the result back to the original object. If we have a look at the object we can see that it now has the new `l100k` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mtcars_dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    mpg cyl disp  hp drat    wt  qsec vs am gear carb    l100k\n1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 11.20048\n2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 11.20048\n3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 10.31623\n4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 10.99112\n5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 12.57807\n6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 12.99503\n```\n:::\n:::\n\n\n`lazy_dt`\n\nLet's have a look at what happens when using `dtplyr` on a `lazy_dt` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_dtp %>% \n    filter(wt < 5) %>% \n    mutate(l100k = 235.21 / mpg) %>%\n    as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 29 × 12\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb l100k\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 11.2 \n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 11.2 \n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 10.3 \n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 11.0 \n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 12.6 \n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 13.0 \n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 16.4 \n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2  9.64\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 10.3 \n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 12.3 \n# … with 19 more rows\n```\n:::\n:::\n\n\nInterestingly we get similar behaviour to `data.table` with respect to coying, in that, no copies are made during the operation. However, it does not modify in place either. If we inspect the original object, there is no `l100k` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_dtp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSource: local data table [32 x 11]\nCall:   `_DT3`\n\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n# … with 26 more rows\n\n# Use as.data.table()/as.data.frame()/as_tibble() to access results\n```\n:::\n:::\n\n\nWe would need to assign it back to `mtcars_dtp` if we wanted to replicate `data.table` behaviour.\n",
    "supporting": [
      "05b_in-mem-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}