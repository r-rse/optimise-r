{
  "hash": "8bcf0b190e8bb9c030892d814df5f7ad",
  "result": {
    "markdown": "---\ntitle: \"Knowing your system\"\n---\n\n\n### System Characteristics\n\nUnderstanding the system code will be run on is an important step to developing and running R code efficiently.\n\nThere are a number of ways to explore your system from within R.\n\n#### `sessionInfo`\n\nThe easiest place to start would be with function `sessionInfo()` which prints version information about **R**, the OS and attached or loaded packages.\n\nHere's the output of `sessionInfo()` on my laptop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n:::\n\n\n    R version 4.2.1 (2022-06-23)\n    Platform: aarch64-apple-darwin21.6.0 (64-bit)\n    Running under: macOS Monterey 12.3.1\n\n    Matrix products: default\n    BLAS:   /opt/homebrew/Cellar/openblas/0.3.21/lib/libopenblasp-r0.3.21.dylib\n    LAPACK: /opt/homebrew/Cellar/r/4.2.1_4/lib/R/lib/libRlapack.dylib\n\n    locale:\n    [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8\n\n    attached base packages:\n    [1] stats     graphics  grDevices datasets  utils     methods   base     \n\n    loaded via a namespace (and not attached):\n    [1] compiler_4.2.1 tools_4.2.1    renv_0.15.5   \n\nApart from information about packages loaded in the current R session, the function also prints some software information including like the Platform and OS version, the Linear Libraries R is using and locale.\n\nNote that `sessionInfo()` displays information about the **software** environment in your current R session.\n\nBut the hardware R is running on is also important to assessing what performance you might be able to achieve and the strategies you might consider to achieve better performance.\n\n## `benchmarkme`\n\n`benchmarkme` is a nifty R package you can use to both access information about both hardware and software available to R on your system as well as functionality to benchmark your system using benchmarks for numerical operations as well as for benchmarking I/O.\n\nLet's use the library to first explore our system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(benchmarkme)\n```\n:::\n\n\nThe package contains a suite of functions for accessing information about your systems hardware and software relevant to R.\n\n-   RAM: `get_ram()`\n\n-   CPUs: `get_cpu()`\n\n-   BLAS library: `get_linear_algebra()`\n\n-   Is byte compiling enabled: `get_byte_compiler()`\n\n-   General platform info: `get_platform_info()`\n\n-   R version: `get_r_version()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_ram()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n34.4 GB\n```\n:::\n\n```{.r .cell-code}\nget_cpu()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vendor_id\ncharacter(0)\n\n$model_name\n[1] \"Apple M1 Pro\"\n\n$no_of_cores\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nget_linear_algebra()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$blas\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\"\n\n$lapack\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\"\n```\n:::\n\n```{.r .cell-code}\nget_byte_compiler()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbyte_optimize \n            2 \n```\n:::\n\n```{.r .cell-code}\nget_platform_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$OS.type\n[1] \"unix\"\n\n$file.sep\n[1] \"/\"\n\n$dynlib.ext\n[1] \".so\"\n\n$GUI\n[1] \"X11\"\n\n$endian\n[1] \"little\"\n\n$pkgType\n[1] \"mac.binary.big-sur-arm64\"\n\n$path.sep\n[1] \":\"\n\n$r_arch\n[1] \"\"\n```\n:::\n\n```{.r .cell-code}\nget_r_version()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$platform\n[1] \"aarch64-apple-darwin20\"\n\n$arch\n[1] \"aarch64\"\n\n$os\n[1] \"darwin20\"\n\n$system\n[1] \"aarch64, darwin20\"\n\n$status\n[1] \"\"\n\n$major\n[1] \"4\"\n\n$minor\n[1] \"2.1\"\n\n$year\n[1] \"2022\"\n\n$month\n[1] \"06\"\n\n$day\n[1] \"23\"\n\n$`svn rev`\n[1] \"82513\"\n\n$language\n[1] \"R\"\n\n$version.string\n[1] \"R version 4.2.1 (2022-06-23)\"\n\n$nickname\n[1] \"Funny-Looking Kid\"\n```\n:::\n:::\n\n\nNote that the BLAS linear library shown here is **libRblas** whereas the previous output which I got by running session info through R in the terminal showed that R was using **openblas**. This is a consequence of running R through RStudio on M1 Macs and will hopefully be rectified at some point.\n\n## Monitoring your system\n\nAll operating systems have dedicated system activity monitors, available through a GUI or through the terminal.\n\n### GUIs\n\nLet's explore what's currently going on on our systems through our OS's dedicated GUI.\n\nDepending on your OS,\n\n-   **macOS:** Activity Monitor\n\n-   **Windows:** Task Manager (\\[How to Open Task Manager in Windows 10\\](https://www.freecodecamp.org/news/how-to-open-task-manager-in-windows-10/))\n\n-   **Linux:** GNOME System Monitor\n\nHere's what Activity Monitor looks like on my Mac.\n\n::: panel-tabset\n## CPU\n\n![](assets/images/am-cpu.png){fig-align=\"center\" width=\"1000\"}\n\n## Memory\n\n![](assets/images/am-memory.png){fig-align=\"center\" width=\"1000\"}\n\n## Disk\n\n![](assets/images/am-disk.png){fig-align=\"center\" width=\"1000\"}\n\n## Network\n\n![](assets/images/am-network.png){fig-align=\"center\" width=\"1000\"}\n:::\n\nCPU, Memory, Disk and Network monitoring is split across tabs but your monitor might show everything in the same tab across different graphs. Some terminology and information shown might differ but ultimately, all monitors attempt to show an overview of similar system activity.\n\nEach row in the monitor table of activities represents a process, each process having its own PID (process ID). They are all controlled by the kernel. As new processes are initiated (for example when we open a new application), the kernel creates a new process for it. If there are multiple cores available on your system, the kernel will allocate new processes to inactive cores. When more processes than cores are running, the kernel uses context switching to keep multiple processes running on a single core.\n\n### Terminal\n\n#### `top`\n\nOn macOS and Linux distributions, the `top` command can also be run in the terminal which initiates system monitoring in the terminal. `top` shows a summary of system activity as well as periodically displaying a list of processes on the system in sorted order. The default key for sorting is pid, but other keys can be used instead.\n\n![](assets/images/top-screenshot.png){width=\"1000\"}\n\n#### Example of Activity monitoring when running R\n\nLet's run the following matrix multiplication code on our system and observe what happens on our system monitor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 4*1024\nA <- matrix( rnorm(n*n), ncol=n, nrow=n )\nB <- matrix( rnorm(n*n), ncol=n, nrow=n )\nC <- A %*% B\n```\n:::\n\n\nThis is what happens when monitoring through `top`. The rsession process moves to the top and, running in a single thread, uses \\~100% of the available CPU while running. When finished, the process drops from the top and goes back to using just 0.2% of CPU as R waits for our next command.\n\n![](assets/images/top.gif)\n\n## Benchmarking your system\n\nAs afforementioned, the **`benchmarkme`** package provides a set of benchmarks to help quantify your system. More interestingly, it allows you to compare your timings with timings crowdsourced on *other* systems.\n\nThere are two groups of benchmarks:\n\n-   `benchmark_std()`: this benchmarks numerical operations such as loops and matrix operations. The benchmark comprises of three separate benchmarks: `prog`, `matrix_fun`, and `matrix_cal`.\n\n-   `benchmark_io()`: this benchmarks reading and writing a 5 / 50, MB csv file.\\\n\nYou can compare your results to other users by assigning the output of the benchmarking to a variable and plotting it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd_bm <- benchmark_std()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n# Programming benchmarks (5 tests):\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t3,500,000 Fibonacci numbers calculation (vector calc): 0.101 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tGrand common divisors of 1,000,000 pairs (recursion): 0.205 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tCreation of a 3,500 x 3,500 Hilbert matrix (matrix calc): 0.116 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tCreation of a 3,000 x 3,000 Toeplitz matrix (loops): 0.573 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tEscoufier's method on a 60 x 60 matrix (mixed): 0.544 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n# Matrix calculation benchmarks (5 tests):\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tCreation, transp., deformation of a 5,000 x 5,000 matrix: 0.196 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t2,500 x 2,500 normal distributed random matrix^1,000: 0.112 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tSorting of 7,000,000 random values: 0.596 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t2,500 x 2,500 cross-product matrix (b = a' * a): 9.48 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tLinear regr. over a 5,000 x 500 matrix (c = a \\ b'): 0.792 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n# Matrix function benchmarks (5 tests):\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tCholesky decomposition of a 3,000 x 3,000 matrix: 5.19 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tDeterminant of a 2,500 x 2,500 random matrix: 1.77 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tEigenvalues of a 640 x 640 random matrix: 0.429 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFFT over 2,500,000 random values: 0.0853 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tInverse of a 1,600 x 1,600 random matrix: 1.4 (sec).\n```\n:::\n\n```{.r .cell-code}\nplot(std_bm)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 1 out of 749 machines.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPress return to get next plot \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 296 out of 747 machines.\n```\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-std-benchmark-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPress return to get next plot \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 174 out of 747 machines.\n```\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-std-benchmark-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-std-benchmark-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nio_bm <- benchmark_io()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPreparing read/write io\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n# IO benchmarks (2 tests) for size 50 MB:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Writing a csv with 6250000 values: 3.38 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Writing a csv with 6250000 values: 3.43 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Writing a csv with 6250000 values: 3.42 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Reading a csv with 6250000 values: 1.2 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Reading a csv with 6250000 values: 1.21 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Reading a csv with 6250000 values: 1.2 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n# IO benchmarks (2 tests) for size 5 MB:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Writing a csv with 625000 values: 0.344 (sec).\n\t Writing a csv with 625000 values: 0.344 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Writing a csv with 625000 values: 0.345 (sec).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\t Reading a csv with 625000 values: 0.119 (sec).\n\t Reading a csv with 625000 values: 0.119 (sec).\n\t Reading a csv with 625000 values: 0.119 (sec).\n```\n:::\n\n```{.r .cell-code}\nplot(io_bm)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 1 out of 119 machines.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPress return to get next plot \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 1 out of 119 machines.\n```\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-io-benchmark-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPress return to get next plot \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 1 out of 135 machines.\n```\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-io-benchmark-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPress return to get next plot \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nYou are ranked 1 out of 135 machines.\n```\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-io-benchmark-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](03_system_files/figure-html/run-io-benchmark-4.png){width=672}\n:::\n:::\n\n\nAll in all my system seems comparatively fast! M1 chips have been shown to be generally very performant and on top of that R is also using the optimised openblas linear algebra library (although not optimised for running multithreaded operations). Having said that I seriously doubt I have the most powerful system out there and it's likely that the timings it's being compared to are somewhat out of date.\n",
    "supporting": [
      "03_system_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}