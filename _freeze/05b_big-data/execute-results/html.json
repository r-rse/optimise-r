{
  "hash": "0b42a75b05eb71bef4a9f125ab0e5f66",
  "result": {
    "markdown": "---\ntitle: \"Data too big for memory\"\nsubtitle: \"Working efficiently with Data\"\n---\n\n\nWe've a look at approaches to speed up working with data in memory more efficiently. But what if the data we want to work with just cannot fit into memory?\n\nThere a number of approaches to deal with this situation which will depend on what exactly we need from the data to perform our operation.\n\nFor example:\n\n-   We might need to process the whole dataset but can somehow split our computation to work on smaller chunks of the data i.e. batch processing. Perhaps our data is split in many individual csv files, in which case we could write a function that works on a single file at a time and use an apply function to process all files and agreggate any result. This sort of processing is highly amenable to parallelisation.\n\n-   We might need a subset of our data which we define through filtering, selecting and other aggregating functions. In this situation, storing our data in a database and using SQL to query it for the subset of data of interest is our best option.\n\n-   A harder problem is when we indeed require all data in memory. Here our choice might require using distributed memory between many machines (e.g. on an HPC platform using MPI) as well as considering options like using single precision floats and mathematical optimisations of our algorithms.\n\n# Databases\n\nDatabases are an appropriate choice if you have large amounts of data that can't fit into memory which you only require subsets from that you can extract using queries.\n\nThere are many types of databases which are beyond the scope of this workshop. What we we will focus on here is simple relational databases that store tabular data in single flat files (a.k.a. embedded databases) as opposed to databases which are run through a server like MySQL, Microsoft SQL Server PostgresSQL or which do not store tabular data, for example MongoDB which stores data as documents.\n\nWe also focus on databases that can be queried using **SQL**. SQL (which stands for Structured Query Language) is a standardized programming language that is used to manage [relational databases](https://www.techtarget.com/searchdatamanagement/definition/relational-database) and perform various operations on the data in them.\n\nIt's good to have an idea of SQL basics when interacting with databases, but in R, many of the `dplyr` verbs are inspired by SQL commands while package `dbplyr` can take dplyr operations and translate them to SQL for querying databases as you would data.frames or tibbles.\n\nAs such we can build up our queries using a connection to a database and only collect our data explicitly when we are ready for R to execute the query.\n\n## SQLite\n\n> [SQLite](https://sqlite.org/index.html) is a C-language library that implements a [small](https://sqlite.org/footprint.html), [fast](https://sqlite.org/fasterthanfs.html), [self-contained](https://sqlite.org/selfcontained.html), [high-reliability](https://sqlite.org/hirely.html), [full-featured](https://sqlite.org/fullsql.html), SQL database engine.\n>\n> The SQLite [file format](https://sqlite.org/fileformat2.html) is stable, cross-platform, and backwards compatible.\n>\n> SQLite [source code](https://sqlite.org/src) is in the [public-domain](https://sqlite.org/copyright.html) and is free to everyone to use for any purpose.\n\nLet's start our experimentation by creating a simple SQLite database with a single table.\n\nThe data we will use is contained in `data/synthpop_10000000.csv` and represents characteristics of 10,000,000 individuals from a synthetic population.\n\nI know this section is about data too big for memory and this is not an approach you can use for data truely larger than memory) but for simplicity of demonstration, we will load the data into memory to populate our database (see the [following blogpost](https://www.michaelc-m.com/manual_posts/2022-01-27-big-CSV-SQL.html) for how to use read_csv_chunked to populate a database in batches).\n\nSo let's load our data and have a look at it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- readr::read_csv(\"data/synthpop_10000000.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 10000000 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): sex, agegr, socprof, marital, edu\ndbl (4): age, income, nociga, bmi\nlgl (3): sport, smoke, alcabuse\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10,000,000 × 12\n   sex      age agegr socprof    income marital edu   sport smoke nociga alcab…¹\n   <chr>  <dbl> <chr> <chr>       <dbl> <chr>   <chr> <lgl> <lgl>  <dbl> <lgl>  \n 1 MALE      47 45-59 FARMER       2000 MARRIED SECO… TRUE  FALSE     NA FALSE  \n 2 FEMALE    43 35-44 OTHER ECO…     NA MARRIED POST… FALSE FALSE     NA FALSE  \n 3 MALE      26 25-34 EMPLOYED …   1400 SINGLE  SECO… FALSE TRUE      15 FALSE  \n 4 FEMALE    51 45-59 EMPLOYED …     NA DIVORC… POST… FALSE FALSE     NA FALSE  \n 5 FEMALE    67 65+   LONG-TERM…    750 WIDOWED VOCA… TRUE  TRUE      20 FALSE  \n 6 MALE      56 45-59 UNEMPLOYED   1200 MARRIED POST… TRUE  FALSE     NA FALSE  \n 7 MALE      86 65+   RETIRED      1260 MARRIED SECO… TRUE  FALSE     NA FALSE  \n 8 MALE      59 45-59 LONG-TERM…   1400 MARRIED POST… TRUE  FALSE     NA FALSE  \n 9 FEMALE    52 45-59 EMPLOYED …   1500 MARRIED SECO… TRUE  TRUE      30 TRUE   \n10 FEMALE    22 16-24 PUPIL OR …    600 SINGLE  SECO… FALSE FALSE     NA FALSE  \n# … with 9,999,990 more rows, 1 more variable: bmi <dbl>, and abbreviated\n#   variable name ¹​alcabuse\n```\n:::\n:::\n\n\nThis is quite a large dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npryr::object_size(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n840.01 MB\n```\n:::\n:::\n\n\nIf it's too big for the RAM on your system, feel free to use one of the smaller synthpop csvs (e.g `data/synthpop_1000000.csv` which contains 1,000,000 rows)\n\nNext let's load some useful libraries, create our database and store the connection to said database in a variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- dbConnect(drv = RSQLite::SQLite(), \"data/db.sqlite\")\n```\n:::\n\n\nThe above command creates an SQLite database at path `data/db.sqlite`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQLiteConnection>\n  Path: /Users/Anna/Documents/workflows/OHID/optimise-r/data/db.sqlite\n  Extensions: TRUE\n```\n:::\n:::\n\n\nWe can also see that the `con` object is tiny, only 2504. That's because it's just a connection to the database and does not contain any data itself.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npryr::object_size(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.50 kB\n```\n:::\n:::\n\n\nNow let's go ahead and write our data to a table in our database. For this we can use `DBI`'s function `dbWriteTable`. This will both create the table in our database and also write the data to it. The arguments we need to provide are:\n\n-    `conn` (the first argument) where we provide the connection to the database we want to write to.\n\n-   `name` the name of the table we want to to create.\n\n-   `value` the object containing the data we want to write to the table. This must be a `data.frame` or an object coercible to a `data.frame`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, name = \"synthpop\", data)\n```\n:::\n\n\nOnce writing the table is complete (this might take a little while), we can do some initial checks on our data using some more `DBI` functions:\n\n-   `dbListTables` lists the names of all tables in the database\n\n-   `dbListFields` lists all fields in a given table (`\"synthpop\"`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"synthpop\"\n```\n:::\n\n```{.r .cell-code}\ndbListFields(con, \"synthpop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"sex\"      \"age\"      \"agegr\"    \"socprof\"  \"income\"   \"marital\" \n [7] \"edu\"      \"sport\"    \"smoke\"    \"nociga\"   \"alcabuse\" \"bmi\"     \n```\n:::\n:::\n\n\n## Interacting with database through `dplyr` & `dbplyr`\n\n`dbplyr` is the database backend for [dplyr](https://dplyr.tidyverse.org/). It allows you to use remote database tables as if they are in-memory data frames by automatically converting dplyr code into SQL.\n\nAll dplyr calls are evaluated lazily, generating SQL that is only sent to the database when you request the data.\n\nSo let's start using our connection to access some data. For that we can use function `tbl()`. Just as `dbConnect()` opens a connection to a database, we can think of `tbl()` as opening a connection to a single table in the database, in this case \\`\"synthpop\"\\`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- tbl(con, \"synthpop\")\n```\n:::\n\n\nIf we print `tbl` we can see all columns in the database and the first 10 rows, which looks a bit like printing a tibble, but if we look at the header of information above the data, we can see the database source as well as `[?? x 12]` in the dimensions summary. That's because `tbl` does not contain the full table data, just a connection to it, and therefore is not aware of the number of rows of the complete table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<synthpop> [?? x 12]\n# Database: sqlite 3.40.0 [/Users/Anna/Documents/workflows/OHID/optimise-r/data/db.sqlite]\n   sex      age agegr socprof    income marital edu   sport smoke nociga alcab…¹\n   <chr>  <dbl> <chr> <chr>       <dbl> <chr>   <chr> <int> <int>  <dbl>   <int>\n 1 MALE      47 45-59 FARMER       2000 MARRIED SECO…     1     0     NA       0\n 2 FEMALE    43 35-44 OTHER ECO…     NA MARRIED POST…     0     0     NA       0\n 3 MALE      26 25-34 EMPLOYED …   1400 SINGLE  SECO…     0     1     15       0\n 4 FEMALE    51 45-59 EMPLOYED …     NA DIVORC… POST…     0     0     NA       0\n 5 FEMALE    67 65+   LONG-TERM…    750 WIDOWED VOCA…     1     1     20       0\n 6 MALE      56 45-59 UNEMPLOYED   1200 MARRIED POST…     1     0     NA       0\n 7 MALE      86 65+   RETIRED      1260 MARRIED SECO…     1     0     NA       0\n 8 MALE      59 45-59 LONG-TERM…   1400 MARRIED POST…     1     0     NA       0\n 9 FEMALE    52 45-59 EMPLOYED …   1500 MARRIED SECO…     1     1     30       1\n10 FEMALE    22 16-24 PUPIL OR …    600 SINGLE  SECO…     0     0     NA       0\n# … with more rows, 1 more variable: bmi <dbl>, and abbreviated variable name\n#   ¹​alcabuse\n```\n:::\n:::\n\n\nLet's have a look at the `tbl` class. The important class identifiers are `\"tbl_dbi\"` and `\"tbl_sql\"` which indicate any data manipulation on the tbl will be translated to SQL, will be lazy and will return another `\"tbl_dbi\"`, not the actual result of the query.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_SQLiteConnection\" \"tbl_dbi\"              \"tbl_sql\"             \n[4] \"tbl_lazy\"             \"tbl\"                 \n```\n:::\n:::\n\n\n### Getting the number of rows of a database table\n\nSo what if we did want to know the number of rows of the `\"synthpop\"` table to double check we have written in fully?\n\nWe might try a familiar R function, `nrow()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nBut this doesn't work! That's because there is no translation of R function `nrow()` to SQL.\n\nWe'll need to frame our request as something that can be translated into an SQL query by `dbplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n    summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.40.0 [/Users/Anna/Documents/workflows/OHID/optimise-r/data/db.sqlite]\n         n\n     <int>\n1 10000000\n```\n:::\n:::\n\n\n`summarise(n())` get's translated to an SQL `COUNT` function, which is an [SQL aggregate function](https://www.sqlite.org/lang_aggfunc.html) that returns one value, hence what is returned to us is another `tbl_dbi` of 1 x 1 dimensions.\n\n::: {.callout-note}\n\nTo learn more about which R functions are translated by dbplyr to SQL have a look at the package's vignettes on [Verb](https://dbplyr.tidyverse.org/articles/translation-verb.html) and [Function](https://dbplyr.tidyverse.org/articles/translation-function.html) translation.\n\n:::\n\nWe can inspect the SQL statement generated by `dbplyr` by piping the query to `dplyr`'s `show_query()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n    summarize(n = n()) %>%\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT COUNT(*) AS `n`\nFROM `synthpop`\n```\n:::\n:::\n\n\nRemember that just running the query returns another `tbl_dbi`. To be able to compute on it in R need to collect it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndb_nrows <- tbl %>% \n    summarize(n = n()) %>%\n    collect()\n\ndb_nrows\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n         n\n     <int>\n1 10000000\n```\n:::\n\n```{.r .cell-code}\npull(db_nrows) == nrow(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nWe have now checked that our data was fully written to our database table.\n\n### Filtering, selecting and summarising\n\nAs mentioned, many of `dplyr` verbs as well as number of aggregating and arithmetic functions can be translated to SQL by `dbplyr`. For greatest it's good to try and perform as many operations in SQL before collecting the data. These are performed by the databases SQL engine which is generally more efficient when working with large data.\n\nLet's try a few examples.\n\nLet's put together a query that filter values in a few columns and then selects a few columns to return:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tbl,\n    age > 30,\n    sex == \"MALE\",\n    sport == TRUE\n) %>%\n    select(income, age, marital)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.40.0 [/Users/Anna/Documents/workflows/OHID/optimise-r/data/db.sqlite]\n   income   age marital\n    <dbl> <dbl> <chr>  \n 1   2000    47 MARRIED\n 2   1200    56 MARRIED\n 3   1260    86 MARRIED\n 4   1400    59 MARRIED\n 5   1100    78 MARRIED\n 6   1500    34 MARRIED\n 7     NA    44 SINGLE \n 8   1500    50 MARRIED\n 9     NA    46 MARRIED\n10     NA    56 MARRIED\n# … with more rows\n```\n:::\n:::\n\n\nAgain, running the query without collecting does not return the full query result but can help check what your query is doing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tbl,\n       age > 30,\n       sex == \"MALE\",\n       sport == TRUE) %>%\n    select(income, age, marital) %>%\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT `income`, `age`, `marital`\nFROM `synthpop`\nWHERE (`age` > 30.0) AND (`sex` = 'MALE') AND (`sport` = 1)\n```\n:::\n:::\n\n\nAnd adding show_query() to the end of the pipe shows the SQL translation of the query.\n\n#### Query 1\n\nLet's try another one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tbl,\n       age > 50L & age < 60L, \n       income < 300) %>%\n    arrange(bmi, age, income, nociga, sex) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:     SQL [?? x 12]\n# Database:   sqlite 3.40.0 [/Users/Anna/Documents/workflows/OHID/optimise-r/data/db.sqlite]\n# Ordered by: bmi, age, income, nociga, sex\n   sex     age agegr socprof     income marital edu   sport smoke nociga alcab…¹\n   <chr> <dbl> <chr> <chr>        <dbl> <chr>   <chr> <int> <int>  <dbl>   <int>\n 1 MALE     51 45-59 OTHER ECON…    200 MARRIED VOCA…     1     0     NA       0\n 2 MALE     51 45-59 OTHER ECON…    200 MARRIED VOCA…     1     0     NA       0\n 3 MALE     51 45-59 OTHER ECON…    200 DIVORC… VOCA…     1     0     NA       0\n 4 MALE     51 45-59 OTHER ECON…    200 MARRIED VOCA…     0     0     NA       0\n 5 MALE     51 45-59 OTHER ECON…    200 LEGALL… VOCA…     1     1     10       0\n 6 MALE     51 45-59 OTHER ECON…    200 SINGLE  PRIM…     1     1     10       0\n 7 MALE     51 45-59 OTHER ECON…    200 LEGALL… VOCA…     1     1     10       1\n 8 MALE     51 45-59 OTHER ECON…    200 LEGALL… VOCA…     1     1     20       1\n 9 MALE     51 45-59 OTHER ECON…    200 DIVORC… VOCA…     1     1     20       1\n10 MALE     51 45-59 OTHER ECON…    200 LEGALL… PRIM…     1     1     20       1\n# … with more rows, 1 more variable: bmi <dbl>, and abbreviated variable name\n#   ¹​alcabuse\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tbl,\n       age > 50L & age < 60L, \n       income < 300) %>%\n    arrange(bmi, age, income, nociga, sex) %>%\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `synthpop`\nWHERE (`age` > 50 AND `age` < 60) AND (`income` < 300.0)\nORDER BY `bmi`, `age`, `income`, `nociga`, `sex`\n```\n:::\n:::\n\n\nLet's wrap this query in a function we can use to benchmark how long it takes to execute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_1 <- function(tbl) {\n    filter(tbl,\n       age > 50L & age < 60L, \n       income < 300) %>%\n    arrange(bmi, age, income, nociga, sex)\n}\n```\n:::\n\n\n#### Query 2\n\nLet's put together one more example to use for benchmarking which includes some aggregating and arithmetic functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tbl,\n       age > 50L,\n       sex == \"MALE\",\n       sport == TRUE,\n       !is.na(income),\n       !is.na(marital)) %>%\n    group_by(marital) %>%\n    summarise(min_income = min(income),\n              max_income = max(income),\n              mean_income = mean(income))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Missing values are always removed in SQL aggregation functions.\nUse `na.rm = TRUE` to silence this warning\nThis warning is displayed once every 8 hours.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.40.0 [/Users/Anna/Documents/workflows/OHID/optimise-r/data/db.sqlite]\n  marital            min_income max_income mean_income\n  <chr>                   <dbl>      <dbl>       <dbl>\n1 DE FACTO SEPARATED        300       7000       1298.\n2 DIVORCED                  100      10000       1395.\n3 LEGALLY SEPARATED         100       9000       1019.\n4 MARRIED                   100      10000       1562.\n5 SINGLE                    100      10000       1221.\n6 WIDOWED                   100      10000       1449.\n```\n:::\n:::\n\n\nLet's look at the SQL translation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tbl,\n       age > 50L,\n       sex == \"MALE\",\n       sport == TRUE,\n       !is.na(income),\n       !is.na(marital)) %>%\n    group_by(marital) %>%\n    summarise(min_income = min(income),\n              max_income = max(income),\n              mean_income = mean(income)) %>%\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  `marital`,\n  MIN(`income`) AS `min_income`,\n  MAX(`income`) AS `max_income`,\n  AVG(`income`) AS `mean_income`\nFROM `synthpop`\nWHERE\n  (`age` > 50) AND\n  (`sex` = 'MALE') AND\n  (`sport` = 1) AND\n  (NOT((`income` IS NULL))) AND\n  (NOT((`marital` IS NULL)))\nGROUP BY `marital`\n```\n:::\n:::\n\n\nAnd again, wrap it in a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_2 <- function(tbl) {\n    filter(tbl,\n       age > 50L,\n       sex == \"MALE\",\n       sport == TRUE,\n       !is.na(income),\n       !is.na(marital)) %>%\n    group_by(marital) %>%\n    summarise(min_income = min(income),\n              max_income = max(income),\n              mean_income = mean(income)) %>%\n        arrange(marital)\n}\n```\n:::\n\n\nOK, let's now run some starting benchmarks against running the same query on the data in memory:\n\n##### Query 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_1(data),\n    sqlite = query_1(tbl) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df            115ms    115ms      8.70   270.3MB     34.8\n2 sqlite        607ms    607ms      1.65    3.49MB      0  \n```\n:::\n:::\n\n\n*Note I've turned off checking for this benchmark because of the difference in how `dplyr` handles `NA`s when arranging data in data.frames (`NA`'s at the end) vs how SQLite's engine does (`NA`'s at the top).*\n\n##### Query 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_2(data),\n    sqlite = query_2(tbl) %>%\n        collect()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df         318.14ms 349.27ms     2.86      524MB    4.29 \n2 sqlite        1.11s    1.11s     0.902     569KB    0.902\n```\n:::\n:::\n\n\nIn this first test of performance, databases come out slower. That shouldn't surprise us though. Working with in memory data (that still allows for the memory required for computation) will always be faster because there is no **I/O** cost to the query (once it has been loaded into memory), whereas executing and collecting the query from the database involves returning the data from disk. We can see though that working with a database is much more memory efficient, which given the topic of the chapter is working with data that does not fit into memory, shows it is a good approach for this use case.\n\n### DuckDB\n\nWhile SQLite is ubiquitous in the world of embedded databases, there is a rather recent type of embedded (flat) called [**DuckDB**](https://duckdb.org/). DuckDB can be far more efficient for analytics queries on large amount of data from a database, more common in analytics workflow.\n\nFrom the [DuckDB website](https://duckdb.org/why_duckdb):\n\n> DuckDB is designed to support **analytical query workloads**, also known as **Online analytical processing (OLAP).**\n>\n> These workloads are characterized by complex, relatively long-running queries that process significant portions of the stored dataset, for example aggregations over entire tables or joins between several large tables.\n>\n> Changes to the data are expected to be rather large-scale as well, with several rows being appended, or large portions of tables being changed or added at the same time.\n>\n> DuckDB contains a [**columnar-vectorized query execution engine**]{.underline}, where queries are still interpreted, but a large batch of values (a \"vector\") are processed in one operation. This greatly reduces overhead present in traditional systems such as PostgreSQL, MySQL or SQLite which process each row sequentially\n\nIt also has a nice API to R handled through package `duckdb`. I highly recommend checking the DuckDB documentation to learn more about it's features, but in general, you can interact with DuckDB databases in R as you would any other database.\n\nSo let's create a DuckDB database with the same data and benchmark our queries against it.\n\nAgain we can use `dbConnect()` to both create a database using a `duckdb::duckdb()` driver and open a connection to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon_duckdb <- dbConnect(duckdb::duckdb(), \"data/db.duckdb\")\ncon_duckdb\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<duckdb_connection dbd60 driver=<duckdb_driver 7e270 dbdir='data/db.duckdb' read_only=FALSE bigint=numeric>>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con_duckdb, \"synthpop\", data)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con_duckdb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"synthpop\"\n```\n:::\n\n```{.r .cell-code}\ndbListFields(con_duckdb, \"synthpop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"sex\"      \"age\"      \"agegr\"    \"socprof\"  \"income\"   \"marital\" \n [7] \"edu\"      \"sport\"    \"smoke\"    \"nociga\"   \"alcabuse\" \"bmi\"     \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_duckdb <- tbl(con_duckdb, \"synthpop\")\ntbl_duckdb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<synthpop> [?? x 12]\n# Database: DuckDB 0.6.2-dev1166 [root@Darwin 21.4.0:R 4.2.1/data/db.duckdb]\n   sex      age agegr socprof    income marital edu   sport smoke nociga alcab…¹\n   <chr>  <dbl> <chr> <chr>       <dbl> <chr>   <chr> <lgl> <lgl>  <dbl> <lgl>  \n 1 MALE      47 45-59 FARMER       2000 MARRIED SECO… TRUE  FALSE     NA FALSE  \n 2 FEMALE    43 35-44 OTHER ECO…     NA MARRIED POST… FALSE FALSE     NA FALSE  \n 3 MALE      26 25-34 EMPLOYED …   1400 SINGLE  SECO… FALSE TRUE      15 FALSE  \n 4 FEMALE    51 45-59 EMPLOYED …     NA DIVORC… POST… FALSE FALSE     NA FALSE  \n 5 FEMALE    67 65+   LONG-TERM…    750 WIDOWED VOCA… TRUE  TRUE      20 FALSE  \n 6 MALE      56 45-59 UNEMPLOYED   1200 MARRIED POST… TRUE  FALSE     NA FALSE  \n 7 MALE      86 65+   RETIRED      1260 MARRIED SECO… TRUE  FALSE     NA FALSE  \n 8 MALE      59 45-59 LONG-TERM…   1400 MARRIED POST… TRUE  FALSE     NA FALSE  \n 9 FEMALE    52 45-59 EMPLOYED …   1500 MARRIED SECO… TRUE  TRUE      30 TRUE   \n10 FEMALE    22 16-24 PUPIL OR …    600 SINGLE  SECO… FALSE FALSE     NA FALSE  \n# … with more rows, 1 more variable: bmi <dbl>, and abbreviated variable name\n#   ¹​alcabuse\n```\n:::\n:::\n\n\n## Benchmark Queries\n\nNow let's go ahead and run our queries again, this time including running them on the `duckdb` database we just created.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_1(data),\n    sqlite = query_1(tbl) %>%\n        collect(),\n    duckdb = query_1(tbl_duckdb) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df          112.3ms    113ms      8.79  269.63MB     5.86\n2 sqlite      605.9ms    606ms      1.65    3.45MB     0   \n3 duckdb       85.9ms     87ms     11.5     1.65MB     2.30\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_2(data),\n    sqlite = query_2(tbl) %>%\n        collect(),\n    duckdb = query_2(tbl_duckdb) %>%\n        collect()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df         276.45ms    332ms     3.01      524MB    1.51 \n2 sqlite        1.11s    1.11s     0.902     532KB    0.902\n3 duckdb     102.49ms 103.44ms     9.64      865KB   13.5  \n```\n:::\n:::\n\n\nWow! DuckDB is much faster than SQLite and even faster than running the queries on in-memory data!! And still very memory efficient.\n\nThis is definitely a database type you should know about!\n\n### Indexing\n\nIndexes are a way to improve the performance of your read queries, particularly ones with filters (`WHERE`) on them. They’re data structures that exist in your database engine, outside of whatever table they work with, that point to data you’re trying to query.\n\nThey work similar to how indexes in the back of a book do. They contain the ordered values of the column you create them on along with information about the location of the rows containing each value in the original table.\n\nSo just like you might use an index to find a recipe instead of flicking through an entire recipe book, database indexes allow you to look up the values in columns and the location of the rows containing them in your original table without scanning the full table. A well crafted index can produce impressive query speedups!\n\nThis does come at a cost. They take up space within your database, increasing it's overall size, and they also slow down updating any tables containing indexes as the indexes must also be updated. Crafting indexes is also a bit of an art, as creating an index that speeds up a given query might actually slow another one down!\n\nThe details of good indexing strategy are a big topic that is well beyond the scope of this workshop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile.copy(\n    from = \"data/db.sqlite\",\n    to = \"data/db_idx.sqlite\"\n)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncon_idx <- dbConnect(RSQLite::SQLite(), \"data/db_idx.sqlite\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con_idx,\n          \"CREATE INDEX synthpop_age_inc_idx ON synthpop (age, income);\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_idx <- tbl(con_idx, \"synthpop\")\ntbl_idx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<synthpop> [?? x 12]\n# Database: sqlite 3.40.0 [/Users/Anna/Documents/workflows/OHID/optimise-r/data/db_idx.sqlite]\n   sex      age agegr socprof    income marital edu   sport smoke nociga alcab…¹\n   <chr>  <dbl> <chr> <chr>       <dbl> <chr>   <chr> <int> <int>  <dbl>   <int>\n 1 MALE      47 45-59 FARMER       2000 MARRIED SECO…     1     0     NA       0\n 2 FEMALE    43 35-44 OTHER ECO…     NA MARRIED POST…     0     0     NA       0\n 3 MALE      26 25-34 EMPLOYED …   1400 SINGLE  SECO…     0     1     15       0\n 4 FEMALE    51 45-59 EMPLOYED …     NA DIVORC… POST…     0     0     NA       0\n 5 FEMALE    67 65+   LONG-TERM…    750 WIDOWED VOCA…     1     1     20       0\n 6 MALE      56 45-59 UNEMPLOYED   1200 MARRIED POST…     1     0     NA       0\n 7 MALE      86 65+   RETIRED      1260 MARRIED SECO…     1     0     NA       0\n 8 MALE      59 45-59 LONG-TERM…   1400 MARRIED POST…     1     0     NA       0\n 9 FEMALE    52 45-59 EMPLOYED …   1500 MARRIED SECO…     1     1     30       1\n10 FEMALE    22 16-24 PUPIL OR …    600 SINGLE  SECO…     0     0     NA       0\n# … with more rows, 1 more variable: bmi <dbl>, and abbreviated variable name\n#   ¹​alcabuse\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_1(tbl_idx) %>%\n    explain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `synthpop`\nWHERE (`age` > 50 AND `age` < 60) AND (`income` < 300.0)\nORDER BY `bmi`, `age`, `income`, `nociga`, `sex`\n\n<PLAN>\n  id parent notused\n1  4      0       0\n2 32      0       0\n                                                              detail\n1 SEARCH synthpop USING INDEX synthpop_age_inc_idx (age>? AND age<?)\n2                                       USE TEMP B-TREE FOR ORDER BY\n```\n:::\n\n```{.r .cell-code}\nquery_1(tbl) %>%\n    explain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `synthpop`\nWHERE (`age` > 50 AND `age` < 60) AND (`income` < 300.0)\nORDER BY `bmi`, `age`, `income`, `nociga`, `sex`\n\n<PLAN>\n  id parent notused                       detail\n1  3      0       0                SCAN synthpop\n2 33      0       0 USE TEMP B-TREE FOR ORDER BY\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con_idx,\n          \"DROP INDEX synthpop_age_inc_idx;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbExecute(con_idx,\n          \"CREATE INDEX synthpop_inc_age_idx ON synthpop (income, age);\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_1(tbl_idx) %>%\n    explain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `synthpop`\nWHERE (`age` > 50 AND `age` < 60) AND (`income` < 300.0)\nORDER BY `bmi`, `age`, `income`, `nociga`, `sex`\n\n<PLAN>\n  id parent notused                                                      detail\n1  4      0       0 SEARCH synthpop USING INDEX synthpop_inc_age_idx (income<?)\n2 35      0       0                                USE TEMP B-TREE FOR ORDER BY\n```\n:::\n\n```{.r .cell-code}\nquery_1(tbl) %>%\n    explain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `synthpop`\nWHERE (`age` > 50 AND `age` < 60) AND (`income` < 300.0)\nORDER BY `bmi`, `age`, `income`, `nociga`, `sex`\n\n<PLAN>\n  id parent notused                       detail\n1  3      0       0                SCAN synthpop\n2 33      0       0 USE TEMP B-TREE FOR ORDER BY\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n   no_index = query_1(tbl) %>%\n    collect(),\n   index = query_1(tbl_idx) %>%\n    collect()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 no_index      609ms  609.3ms      1.64    3.44MB     1.64\n2 index          64ms   64.7ms     15.4     3.44MB     1.93\n```\n:::\n:::\n\n\nLet's check whether it also helps with query 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n   no_index = query_2(tbl) %>%\n    collect(),\n   index = query_2(tbl_idx) %>%\n    collect()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 no_index       1.1s     1.1s     0.908     531KB    1.82 \n2 index          1.1s     1.1s     0.907     531KB    0.907\n```\n:::\n:::\n\n\nWell that's not good! The index seems to have made query 2 slower?! If we use `explain()` to dig into it\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_2(tbl_idx) %>%\n    explain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  `marital`,\n  MIN(`income`) AS `min_income`,\n  MAX(`income`) AS `max_income`,\n  AVG(`income`) AS `mean_income`\nFROM `synthpop`\nWHERE\n  (`age` > 50) AND\n  (`sex` = 'MALE') AND\n  (`sport` = 1) AND\n  (NOT((`income` IS NULL))) AND\n  (NOT((`marital` IS NULL)))\nGROUP BY `marital`\nORDER BY `marital`\n\n<PLAN>\n  id parent notused                       detail\n1  7      0       0                SCAN synthpop\n2 21      0       0 USE TEMP B-TREE FOR GROUP BY\n```\n:::\n\n```{.r .cell-code}\nquery_2(tbl) %>%\n    explain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  `marital`,\n  MIN(`income`) AS `min_income`,\n  MAX(`income`) AS `max_income`,\n  AVG(`income`) AS `mean_income`\nFROM `synthpop`\nWHERE\n  (`age` > 50) AND\n  (`sex` = 'MALE') AND\n  (`sport` = 1) AND\n  (NOT((`income` IS NULL))) AND\n  (NOT((`marital` IS NULL)))\nGROUP BY `marital`\nORDER BY `marital`\n\n<PLAN>\n  id parent notused                       detail\n1  7      0       0                SCAN synthpop\n2 21      0       0 USE TEMP B-TREE FOR GROUP BY\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con_idx,\n          \"CREATE INDEX synthpop_inc_mar_age_sex_sp_idx ON synthpop (income, marital, age, sex, sport);\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n   no_index = query_2(tbl) %>%\n    collect(),\n   index = query_2(tbl_idx) %>%\n    collect()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 no_index      1.12s    1.12s     0.889     531KB    0.889\n2 index      867.93ms 867.93ms     1.15      531KB    2.30 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n   no_index = query_1(tbl) %>%\n    collect(),\n   index = query_1(tbl_idx) %>%\n    collect(),\n   duckdb = query_1(tbl_duckdb) %>%\n    collect(),\n   check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 no_index    604.2ms  604.2ms      1.66    3.44MB     0   \n2 index        64.2ms   64.7ms     15.4     3.44MB     5.14\n3 duckdb       86.4ms     87ms     11.5     1.58MB     5.75\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n   no_index = query_2(tbl) %>%\n    collect(),\n   index = query_2(tbl_idx) %>%\n    collect(),\n   duckdb = query_2(tbl_duckdb) %>%\n    collect()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 no_index      1.11s    1.11s     0.900     531KB    0.900\n2 index      865.21ms 865.21ms     1.16      531KB    2.31 \n3 duckdb     104.06ms  105.1ms     9.44      859KB   13.2  \n```\n:::\n:::\n\n\n## Arrow Datasets\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_tbl <- arrow::read_csv_arrow(\"data/synthpop_10000000.csv\", \n                      as_data_frame = FALSE)\n\nbench::mark(in_mem_csv = query_1(data),\n            arrow_tbl = query_1(arrow_tbl) %>%\n    collect(),\n    check = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 in_mem_csv  113.5ms    114ms      8.78  269.63MB    13.2 \n2 arrow_tbl    46.8ms   48.2ms     20.8     5.75MB     5.93\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_dt_csv <- arrow::open_dataset(\"data/synthpop_10000000.csv\", format = \"csv\")\n\n\n\n\nbench::mark(\n    df = query_1(data),\n    sqlite = query_1(tbl) %>%\n        collect(),\n    duckdb = query_1(tbl_duckdb) %>%\n        collect(),\n    arrow_dt_csv = query_1(arrow_dt_csv) %>%\n    collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  expression        min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df           112.91ms    114ms     8.72   269.63MB     2.18\n2 sqlite       605.18ms 605.18ms     1.65     3.44MB     0   \n3 duckdb        86.94ms  87.46ms    11.4      1.58MB    11.4 \n4 arrow_dt_csv    3.46s    3.46s     0.289  460.44KB     0   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_create(\"data/arrow_dataset\")\narrow::write_dataset(data, \n                     path = \"data/arrow_dataset/arrow_dat1\",\n                     format = \"parquet\",\n                     partitioning = \"age\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_tree(\"data/arrow_dataset/arrow_dat1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata/arrow_dataset/arrow_dat1\n├── age=16\n│   └── part-0.parquet\n├── age=17\n│   └── part-0.parquet\n├── age=18\n│   └── part-0.parquet\n├── age=19\n│   └── part-0.parquet\n├── age=20\n│   └── part-0.parquet\n├── age=21\n│   └── part-0.parquet\n├── age=22\n│   └── part-0.parquet\n├── age=23\n│   └── part-0.parquet\n├── age=24\n│   └── part-0.parquet\n├── age=25\n│   └── part-0.parquet\n├── age=26\n│   └── part-0.parquet\n├── age=27\n│   └── part-0.parquet\n├── age=28\n│   └── part-0.parquet\n├── age=29\n│   └── part-0.parquet\n├── age=30\n│   └── part-0.parquet\n├── age=31\n│   └── part-0.parquet\n├── age=32\n│   └── part-0.parquet\n├── age=33\n│   └── part-0.parquet\n├── age=34\n│   └── part-0.parquet\n├── age=35\n│   └── part-0.parquet\n├── age=36\n│   └── part-0.parquet\n├── age=37\n│   └── part-0.parquet\n├── age=38\n│   └── part-0.parquet\n├── age=39\n│   └── part-0.parquet\n├── age=40\n│   └── part-0.parquet\n├── age=41\n│   └── part-0.parquet\n├── age=42\n│   └── part-0.parquet\n├── age=43\n│   └── part-0.parquet\n├── age=44\n│   └── part-0.parquet\n├── age=45\n│   └── part-0.parquet\n├── age=46\n│   └── part-0.parquet\n├── age=47\n│   └── part-0.parquet\n├── age=48\n│   └── part-0.parquet\n├── age=49\n│   └── part-0.parquet\n├── age=50\n│   └── part-0.parquet\n├── age=51\n│   └── part-0.parquet\n├── age=52\n│   └── part-0.parquet\n├── age=53\n│   └── part-0.parquet\n├── age=54\n│   └── part-0.parquet\n├── age=55\n│   └── part-0.parquet\n├── age=56\n│   └── part-0.parquet\n├── age=57\n│   └── part-0.parquet\n├── age=58\n│   └── part-0.parquet\n├── age=59\n│   └── part-0.parquet\n├── age=60\n│   └── part-0.parquet\n├── age=61\n│   └── part-0.parquet\n├── age=62\n│   └── part-0.parquet\n├── age=63\n│   └── part-0.parquet\n├── age=64\n│   └── part-0.parquet\n├── age=65\n│   └── part-0.parquet\n├── age=66\n│   └── part-0.parquet\n├── age=67\n│   └── part-0.parquet\n├── age=68\n│   └── part-0.parquet\n├── age=69\n│   └── part-0.parquet\n├── age=70\n│   └── part-0.parquet\n├── age=71\n│   └── part-0.parquet\n├── age=72\n│   └── part-0.parquet\n├── age=73\n│   └── part-0.parquet\n├── age=74\n│   └── part-0.parquet\n├── age=75\n│   └── part-0.parquet\n├── age=76\n│   └── part-0.parquet\n├── age=77\n│   └── part-0.parquet\n├── age=78\n│   └── part-0.parquet\n├── age=79\n│   └── part-0.parquet\n├── age=80\n│   └── part-0.parquet\n├── age=81\n│   └── part-0.parquet\n├── age=82\n│   └── part-0.parquet\n├── age=83\n│   └── part-0.parquet\n├── age=84\n│   └── part-0.parquet\n├── age=85\n│   └── part-0.parquet\n├── age=86\n│   └── part-0.parquet\n├── age=87\n│   └── part-0.parquet\n├── age=88\n│   └── part-0.parquet\n├── age=89\n│   └── part-0.parquet\n├── age=90\n│   └── part-0.parquet\n├── age=91\n│   └── part-0.parquet\n├── age=92\n│   └── part-0.parquet\n├── age=96\n│   └── part-0.parquet\n└── age=97\n    └── part-0.parquet\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# parquet arrow data set\nfs::dir_info(\"data/arrow_dataset/arrow_dat1\", recurse = TRUE)$size %>% sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n140M\n```\n:::\n\n```{.r .cell-code}\n# original csv\nfs::file_size(\"data/synthpop_10000000.csv\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n967M\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_dataset1 <- arrow::open_dataset(\"data/arrow_dataset/arrow_dat1\", format = \"parquet\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_1(data),\n    sqlite = query_1(tbl) %>%\n        collect(),\n    duckdb = query_1(tbl_duckdb) %>%\n        collect(),\n    arrow_dt_csv = query_1(arrow_dt_csv) %>%\n    collect(),\n    arrow_dataset = query_1(arrow_dataset1) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n  expression         min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df            113.28ms 113.57ms     8.80   269.63MB     8.80\n2 sqlite        611.34ms 611.34ms     1.64     3.47MB     0   \n3 duckdb         85.97ms  87.38ms    11.5      1.58MB     2.87\n4 arrow_dt_csv     3.49s    3.49s     0.287  448.38KB     0   \n5 arrow_dataset 599.79ms 599.79ms     1.67   955.34KB     0   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_2(data),\n    sqlite = query_2(tbl) %>%\n        collect(),\n    duckdb = query_2(tbl_duckdb) %>%\n        collect(),\n    arrow_dt_csv = query_2(arrow_dt_csv) %>%\n        collect(),\n    arrow_dataset = query_2(arrow_dataset1) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n  expression         min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df             275.6ms 282.91ms     3.53   523.91MB    1.77 \n2 sqlite           1.11s    1.11s     0.900   548.8KB    0    \n3 duckdb        103.92ms 108.04ms     9.22   875.55KB    7.37 \n4 arrow_dt_csv     2.49s    2.49s     0.402    2.28MB    0.402\n5 arrow_dataset    1.33s    1.33s     0.751   219.8KB    0    \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narrow::write_dataset(data, \n                     path = \"data/arrow_dataset/arrow_dat2\",\n                     format = \"parquet\",\n                     partitioning = c(\"age\", \"marital\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_tree(\"data/arrow_dataset/arrow_dat2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata/arrow_dataset/arrow_dat2\n├── age=16\n│   └── marital=SINGLE\n│       └── part-0.parquet\n├── age=17\n│   └── marital=SINGLE\n│       └── part-0.parquet\n├── age=18\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=19\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=20\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=21\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=22\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=23\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=24\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=25\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=26\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=27\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=28\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   └── marital=SINGLE\n│       └── part-0.parquet\n├── age=29\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   └── marital=SINGLE\n│       └── part-0.parquet\n├── age=30\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   └── marital=SINGLE\n│       └── part-0.parquet\n├── age=31\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=32\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=33\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=34\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=35\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=36\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=37\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=38\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=39\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=40\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=41\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=42\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=43\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=44\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=45\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=46\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=47\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=48\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=49\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=50\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=51\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=52\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=53\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=54\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=55\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=56\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=57\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=58\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=59\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=60\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=61\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=62\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=63\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=64\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=65\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=66\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=67\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=68\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=69\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=70\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=71\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=72\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=73\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=74\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=75\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=76\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=77\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=78\n│   ├── marital=DE FACTO SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   ├── marital=WIDOWED\n│   │   └── part-0.parquet\n│   └── marital=__HIVE_DEFAULT_PARTITION__\n│       └── part-0.parquet\n├── age=79\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=80\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=81\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=LEGALLY SEPARATED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=82\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=83\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=84\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=85\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=86\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=87\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=88\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=89\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=90\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=91\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=92\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n├── age=96\n│   ├── marital=DIVORCED\n│   │   └── part-0.parquet\n│   ├── marital=MARRIED\n│   │   └── part-0.parquet\n│   ├── marital=SINGLE\n│   │   └── part-0.parquet\n│   └── marital=WIDOWED\n│       └── part-0.parquet\n└── age=97\n    ├── marital=MARRIED\n    │   └── part-0.parquet\n    ├── marital=SINGLE\n    │   └── part-0.parquet\n    └── marital=WIDOWED\n        └── part-0.parquet\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_dataset2 <- arrow::open_dataset(\"data/arrow_dataset/arrow_dat2\", format = \"parquet\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_1(data),\n    sqlite = query_1(tbl) %>%\n        collect(),\n    duckdb = query_1(tbl_duckdb) %>%\n        collect(),\n    arrow_dt_csv = query_1(arrow_dt_csv) %>%\n    collect(),\n    arrow_dataset_1 = query_1(arrow_dataset1) %>%\n        collect(),\n    arrow_dataset_2 = query_1(arrow_dataset2) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df              112.71ms 113.43ms     8.81   269.63MB     2.20\n2 sqlite          614.96ms 614.96ms     1.63     3.44MB     0   \n3 duckdb           85.58ms  87.58ms    11.5      1.58MB     2.29\n4 arrow_dt_csv       3.52s    3.52s     0.284  448.38KB     0   \n5 arrow_dataset_1 602.41ms 602.41ms     1.66   359.78KB     0   \n6 arrow_dataset_2    2.11s    2.11s     0.474  359.78KB     0   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_2(data),\n    sqlite = query_2(tbl) %>%\n        collect(),\n    duckdb = query_2(tbl_duckdb) %>%\n        collect(),\n    arrow_dt_csv = query_2(arrow_dt_csv) %>%\n    collect(),\n    arrow_dataset = query_2(arrow_dataset1) %>%\n        collect(),\n    arrow_dataset_2 = query_2(arrow_dataset2) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df              292.57ms 298.92ms     3.35      524MB    1.67 \n2 sqlite             1.13s    1.13s     0.888     547KB    0    \n3 duckdb           101.3ms 105.31ms     9.24      875KB    7.39 \n4 arrow_dt_csv        2.5s     2.5s     0.400     189KB    0.400\n5 arrow_dataset      1.33s    1.33s     0.751     219KB    0    \n6 arrow_dataset_2    4.01s    4.01s     0.249     219KB    0    \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narrow::write_dataset(data, \n                     path = \"data/arrow_dataset/arrow_dat3\",\n                     format = \"parquet\",\n                     partitioning = c(\"age\", \"sex\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_dataset3 <- arrow::open_dataset(\"data/arrow_dataset/arrow_dat3\", format = \"parquet\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    df = query_2(data),\n    sqlite = query_2(tbl) %>%\n        collect(),\n    duckdb = query_2(tbl_duckdb) %>%\n        collect(),\n    arrow_dt_csv = query_2(arrow_dt_csv) %>%\n    collect(),\n    arrow_dataset = query_2(arrow_dataset1) %>%\n        collect(),\n    arrow_dataset_2 = query_2(arrow_dataset2) %>%\n        collect(),\n    arrow_dataset_3 = query_2(arrow_dataset3) %>%\n        collect(),\n    check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is disabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 df              284.04ms 291.05ms     3.44      524MB    1.72 \n2 sqlite             1.11s    1.11s     0.900     546KB    0    \n3 duckdb          104.35ms 106.04ms     9.19      875KB    7.35 \n4 arrow_dt_csv       2.48s    2.48s     0.403     189KB    0.403\n5 arrow_dataset      1.32s    1.32s     0.758     219KB    0    \n6 arrow_dataset_2    4.04s    4.04s     0.248     219KB    0    \n7 arrow_dataset_3 989.96ms 989.96ms     1.01      219KB    0    \n```\n:::\n:::\n\n\n# Batch processing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_names <- fs::dir_ls(\"data/arrow_dataset/arrow_dat1\", \n                         recurse = TRUE,\n                         type = \"file\")\n\nbatch_mean <- function(file_name) {\n    dat <- arrow::read_parquet(file_name, col_select = \"income\")\n    \n    income_vct <- na.omit(dat[[\"income\"]])\n    \n    c(mean = mean(income_vct),\n      n = length(income_vct))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- purrr::map_dfr(file_names, ~batch_mean(.x))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 79 × 2\n    mean      n\n   <dbl>  <dbl>\n 1  543.   5138\n 2  530.  17675\n 3  548.  20947\n 4  678.  21002\n 5  770.  17801\n 6 1109.  71922\n 7 1107.  89002\n 8 1275.  95972\n 9 1411.  92471\n10 1555. 115432\n# … with 69 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nweighted.mean(x = means$mean, w = means$n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1639.416\n```\n:::\n\n```{.r .cell-code}\nmean(data$income, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1639.416\n```\n:::\n:::\n\n\n\n\n## Chunking data\n\n### Reading portions of csv files\n\n## Memory mapping data\n\n`mmap`\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}